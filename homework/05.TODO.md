# Домашнее задание №5
17.08-23.08
## Содержание
1. [Задание](#task)
    - [Checklist ](#checklist)
2. [Разработка ленты новостей социальной сети](#dev)
3. [Развертывание проекта в heroku](#heroku)
4. [Вывод](#summary)

<a name="task"></a>
## Задание
Лента новостей социальной сети

Цель:
- В результате выполнения ДЗ вы создадите ленту новостей социальной сети.

В данном задании тренируются навыки:
- работа с кешами;
- работа с очередями;
- проектирование масштабируемых архитектур.

Требования:
- Разработать ленту новостей.
- Добавить функционал "добавление поста".
- Создается отдельная страница, куда пишутся все обновления друзей. Для этого нужно хранить подписчиков.
- Лента формируется на уровне кешей.
- Формирование ленты производить через постановку задачи в очередь на часть подписчиков, чтобы избежать эффекта леди Гаги.
- В ленте держать последние 1000 обновлений друзей.
- Лента должна кешироваться.

ДЗ сдается в виде ссылки на гитлаб и демонстрации работающего проекта, развернутого в интернете.

Критерии оценки:
Оценка происходит по принципу зачет/незачет.

Требования: Верно работает инвалидация кеша. Обновление лент работает через очередь. Есть возможность перестройки кешей из СУБД.

<a name="checklist"></a>
## Checklist
1. Разработать ленту новостей социальной сети
    - Добавить функционал "добавление поста"
    - Создать отдельную страницу, куда пишутся все обновления друзей. Для этого нужно хранить подписчиков
    - Лента формируется на уровне кешей
    - Формирование ленты производить через постановку задачи в очередь на часть подписчиков, чтобы избежать эффекта леди Гаги
    - В ленте держать последние 1000 обновлений друзей
    - Лента должна кешироваться
    - Верно работает инвалидация кеша
    - Обновление лент работает через очередь
    - Есть возможность перестройки кешей из СУБД
3. Развертывание проекта в heroku
4. Вывод

<a name="dev"></a>
## Разработка ленты новостей социальной сети

- в БД добавлена кросс-таблица subscribers
- в качестве очереди выбран rabbitmq
- в качестве кэша выбран redis  
    Для кэшей лент пользователей используется тип streams, в качестве ключа используется время создания поста в формате int.  
    Таким образом отпадает необходимость сортировки кэша ленты пользователя. Т.к. сообщения идут по порядку создания(created, не modified).  
    в операциях по работе с кэшем используются транзакции (redis).

### Добавлены эндпоинты:  

#### /post/edit [POST] #добавление/обновление поста
 - сохранение поста в БД
 - получение списка подписчиков из БД
 - Далее
    - если пост новый  
		В очередь "update_feed" отправляются сообщения для обновления (append) кэшей с содержанием <пост,подписчики>.  
        Сообщения бьются по ограниченному количеству подписчиков.  
        Т.е. если у автора 1000 подписчиков и размер бакета 100 подписчиков, то одно сообщение разобьется на 10.  
        далее при чтении очереди пост добавляется в конец кэша каждого подписчика.
    - при обновлении поста  
        В БД для всех подписчиков устанавливается флаг на инвалидацию кэша.  
        В очередь "rebuld_feed" кладется сообщение для ребилда кэша.  
        Далее при чтении очереди "rebuld_feed" проверяется флаг инвалидации у подписчика  
        и если он активен, то запускается перестройка кэша и флаг инвалидации сбрасывается.  
        Таким образом флаг снимает нагрузку на постоянный ребилд кэша, даже если пользователи часто удаляют/правят свои посты.  
        Ребилд будет происходить только при изменении актуального состояния ленты пользователя.  
        После наполнения очереди отправляется сообщение "reset" в отдельный stream для пользователя.  

#### /user/<username> [GET] #страница пользователя  
 - содержит только посты пользователя


#### /feed [GET] #лента новостей
 - содержит последние 1000 постов пользователей, на которые подписан user.  
 - обновляется с помощью websocket  
    Раз в 2 сек проверяются новые сообщения в кэше. (используется текущий указатель id в streams).  
    Если есть новые сообщения они отображаются в ленте.  
    При получении сообщения reset (допустим ктото удалил пост), лента в браузере очищается,  
    текущий указатель стрима редиса устанавливается в 0, и лента заново наполняется из кэша.  

#### /user/<username>subscribe [POST] #подписка
 - в БД обновляется статус подписки
 - в очередь "rebuld_feed" кладется сообщение для ребилда кэша

#### /user/<username>unsubscribe [POST] #отписка
 - в БД обновляется статус подписки
 - в очередь "rebuld_feed" кладется сообщение для ребилда кэша


<a name="heroku"></a>
## Развертывание проекта в heroku

Проект развернут в heroku.  
Используется mysql, rabbitmq, redis каждый по 1 инстансу.

<a name="summary"></a>
## Вывод

Было интересно поработать над подобной архитектурой.  
С одной стороны подходы все понятны. Но встечается немало кейсов, которые трудно предугадывать с самого начала и приходится както обходить.  
